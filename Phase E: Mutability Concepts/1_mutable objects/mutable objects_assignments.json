{
  "topic": "mutable objects",
  "assignments": [
    {
      "index": 1,
      "fileName": "01_listMutationBasics.py",
      "content": "# Goal: Practice basic list mutation with append and index assignment.\n# Expected outcome: prints exactly: [10, 99, 30, 40]\n\ndef main():\n    nums = [10, 20, 30]\n\n    # TODO: append 40 to nums\n    \n    # TODO: change the second element (index 1) to 99\n    \n    print(nums)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "fileName": "02_sliceAssignment.py",
      "content": "# Goal: Use slice assignment to mutate a list in-place.\n# Expected outcome: prints exactly: [1, 2, 7, 8, 5]\n\ndef main():\n    data = [1, 2, 3, 4, 5]\n\n    # TODO: replace the middle two elements (3,4) with (7,8) using slice assignment\n    # Hint: data[?, ?] = [7, 8]\n\n    print(data)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "fileName": "03_aliasingSameList.py",
      "content": "# Goal: Understand aliasing: two variables referencing the same mutable list.\n# Expected outcome: prints exactly:\n# a: [\"x\", \"y\", \"z\"]\n# b: [\"x\", \"y\", \"z\"]\n\ndef main():\n    a = [\"x\", \"y\"]\n\n    # TODO: make b refer to the SAME list object as a (aliasing)\n    b = None\n\n    # TODO: mutate the list through b so that the shared list becomes [\"x\",\"y\",\"z\"]\n\n    print(\"a:\", a)\n    print(\"b:\", b)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "fileName": "04_avoidingAliasingCopy.py",
      "content": "# Goal: Avoid unintended shared mutation using a shallow copy.\n# Expected outcome: prints exactly:\n# original: [1, 2, 3]\n# copy: [1, 2, 3, 99]\n\ndef main():\n    original = [1, 2, 3]\n\n    # TODO: create a shallow copy of original and store in copied\n    copied = None\n\n    # TODO: mutate copied to add 99 without changing original\n\n    print(\"original:\", original)\n    print(\"copy:\", copied)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "fileName": "05_dictMutationBasics.py",
      "content": "# Goal: Add, update, and delete keys in a dictionary.\n# Expected outcome: prints exactly: {'name': 'Ada', 'age': 37}\n\ndef main():\n    person = {\"name\": \"Ada\"}\n\n    # TODO: add key \"age\" with value 36\n\n    # TODO: update \"age\" to 37\n\n    # TODO: add a temporary key \"temp\" then delete it\n\n    print(person)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "fileName": "06_listInsideDictMutation.py",
      "content": "# Goal: Mutate a list stored inside a dictionary.\n# Expected outcome: prints exactly: {'tags': ['python', 'mutability', 'lists']}\n\ndef main():\n    item = {\"tags\": [\"python\", \"mutability\"]}\n\n    # TODO: append \"lists\" to the list inside the dict\n\n    print(item)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "fileName": "07_functionMutatesList.py",
      "content": "# Goal: Show that functions can mutate passed-in mutable objects.\n# Expected outcome: prints exactly: [2, 4, 6]\n\n\ndef double_in_place(nums):\n    # TODO: mutate nums so each element is doubled, in-place\n    # Do not create and return a new list.\n    pass\n\n\ndef main():\n    data = [1, 2, 3]\n    double_in_place(data)\n    print(data)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 8,
      "fileName": "08_defaultMutableArgumentTrap.py",
      "content": "# Goal: Avoid the mutable default argument pitfall.\n# Expected outcome: prints exactly:\n# ['a']\n# ['b']\n\n\ndef add_item(item, bucket=None):\n    # TODO: implement so that each call without an explicit bucket\n    # starts with a fresh list (no shared state between calls).\n    # Must return the list.\n    pass\n\n\ndef main():\n    print(add_item(\"a\"))\n    print(add_item(\"b\"))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 9,
      "fileName": "09_shallowCopyNestedList.py",
      "content": "# Goal: Observe shallow copy behavior with nested lists.\n# Expected outcome: prints exactly:\n# original: [[1, 99], [3, 4]]\n# shallow: [[1, 99], [3, 4]]\n\n\ndef main():\n    original = [[1, 2], [3, 4]]\n\n    # TODO: make a shallow copy of original (outer list only)\n    shallow = None\n\n    # TODO: mutate the first inner list so that 2 becomes 99\n\n    print(\"original:\", original)\n    print(\"shallow:\", shallow)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 10,
      "fileName": "10_deepCopyNestedList.py",
      "content": "# Goal: Use deep copy to prevent nested mutation from affecting the original.\n# Expected outcome: prints exactly:\n# original: [[1, 2], [3, 4]]\n# deep: [[1, 99], [3, 4]]\n\nimport copy\n\n\ndef main():\n    original = [[1, 2], [3, 4]]\n\n    # TODO: create a deep copy of original\n    deep = None\n\n    # TODO: mutate deep so that the first inner list's second element becomes 99\n\n    print(\"original:\", original)\n    print(\"deep:\", deep)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 11,
      "fileName": "11_inPlaceVsNewList.py",
      "content": "# Goal: Distinguish in-place mutation from creating a new list.\n# Expected outcome: prints exactly:\n# same_object: True\n# nums: [3, 1, 2]\n\n\ndef main():\n    nums = [3, 1, 2]\n    before_id = id(nums)\n\n    # TODO: sort nums in-place (do not assign nums to a new list)\n\n    after_id = id(nums)\n\n    print(\"same_object:\", before_id == after_id)\n    print(\"nums:\", nums)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 12,
      "fileName": "12_safeRemovalWhileIterating.py",
      "content": "# Goal: Remove items from a list safely.\n# Expected outcome: prints exactly: [1, 3, 5]\n\n\ndef main():\n    nums = [1, 2, 3, 4, 5, 6]\n\n    # TODO: remove all even numbers from nums.\n    # Constraint: Do NOT build a brand-new list with a comprehension.\n    # Mutate nums so it ends as [1,3,5].\n\n    print(nums)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 13,
      "fileName": "13_dictOfListsAccumulate.py",
      "content": "# Goal: Accumulate values into lists within a dictionary.\n# Expected outcome: prints exactly: {'fruit': ['apple', 'banana'], 'veg': ['carrot']}\n\n\ndef add_to_group(groups, category, item):\n    # TODO: mutate groups so that groups[category] is a list that includes item.\n    # If category doesn't exist, create it with an empty list first.\n    pass\n\n\ndef main():\n    groups = {}\n    add_to_group(groups, \"fruit\", \"apple\")\n    add_to_group(groups, \"fruit\", \"banana\")\n    add_to_group(groups, \"veg\", \"carrot\")\n    print(groups)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 14,
      "fileName": "14_sharedReferenceBugFix.py",
      "content": "# Goal: Fix a shared-reference bug when creating a matrix (list of lists).\n# Expected outcome: prints exactly:\n# [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n\n\ndef make_grid(rows, cols):\n    # BUGGY starter (do not keep as-is):\n    # return [[0] * cols] * rows\n\n    # TODO: implement make_grid so each row is an independent list.\n    pass\n\n\ndef main():\n    grid = make_grid(3, 3)\n\n    # Set center cell to 1\n    grid[1][1] = 1\n\n    print(grid)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 15,
      "fileName": "15_mutableObjectIdentityTracker.py",
      "content": "# Goal: Track and verify object identity across mutations and copies.\n# Expected outcome: prints exactly:\n# same_after_mutation: True\n# same_after_shallow_copy: False\n# alias_reflects_change: True\n# final: {'a': [1, 2, 3, 4], 'b': [1, 2, 3, 4], 'c': [1, 2, 3]}\n\n\ndef main():\n    data = {\"a\": [1, 2, 3]}\n\n    # TODO: create b as an alias to the same list as data['a'] (not a copy)\n    b = None\n\n    # TODO: create c as a shallow copy of data['a']\n    c = None\n\n    before_id = id(data[\"a\"])\n\n    # TODO: mutate data['a'] by appending 4\n\n    after_id = id(data[\"a\"])\n\n    # TODO: compute booleans:\n    # same_after_mutation: True if the list object identity didn't change\n    # same_after_shallow_copy: False if c is a different object than data['a']\n    # alias_reflects_change: True if b sees the appended 4\n    same_after_mutation = None\n    same_after_shallow_copy = None\n    alias_reflects_change = None\n\n    print(\"same_after_mutation:\", same_after_mutation)\n    print(\"same_after_shallow_copy:\", same_after_shallow_copy)\n    print(\"alias_reflects_change:\", alias_reflects_change)\n    print(\"final:\", {\"a\": data[\"a\"], \"b\": b, \"c\": c})\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ]
}